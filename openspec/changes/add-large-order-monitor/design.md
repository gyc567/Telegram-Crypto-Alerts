# å¤§é¢äº¤æ˜“ç›‘æ§åŠŸèƒ½ - æŠ€æœ¯è®¾è®¡æ–‡æ¡£

## ğŸ“‹ è®¾è®¡æ¦‚è§ˆ

**ææ¡ˆç¼–å·**: CHANGE-2025-0104
**ç‰ˆæœ¬**: 1.0.0
**åˆ›å»ºæ—¥æœŸ**: 2025-11-10
**è®¾è®¡è€…**: OpenSpec AIåŠ©æ‰‹

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ€§èƒ½ç›®æ ‡
- **CPUä½¿ç”¨ç‡**: ä»20%é™ä½åˆ°2% (â†“80%)
- **å†…å­˜ä½¿ç”¨**: ä»200MBé™ä½åˆ°100MB (â†“50%)
- **å“åº”å»¶è¿Ÿ**: ä»10-15ç§’é™ä½åˆ°<1ç§’ (â†“90%+)
- **ç³»ç»Ÿç¨³å®šæ€§**: ä»95%æå‡åˆ°99.5% (â†‘4.5%)

### åŠŸèƒ½ç›®æ ‡
- å®æ—¶ç›‘æ§20+ä¸»æµäº¤æ˜“å¯¹
- 5åˆ†é’Ÿæ»šåŠ¨çª—å£èšåˆ
- $2,000,000 USDé˜ˆå€¼æ£€æµ‹
- 5åˆ†é’Ÿå†·å´æœºåˆ¶
- è‡ªåŠ¨é”™è¯¯æ¢å¤

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                å¤§é¢äº¤æ˜“ç›‘æ§ç³»ç»Ÿ (äº‹ä»¶é©±åŠ¨)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    äº‹ä»¶æµ    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   WebSocket  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚     äº‹ä»¶     â”‚            â”‚
â”‚  â”‚   ç®¡ç†å™¨     â”‚              â”‚    æ€»çº¿      â”‚            â”‚
â”‚  â”‚              â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                        â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  è®¢å•èšåˆå™¨  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  èšåˆè¯·æ±‚   â”‚            â”‚
â”‚  â”‚              â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                        â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  é˜ˆå€¼å¼•æ“    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  é˜ˆå€¼æ£€æŸ¥   â”‚            â”‚
â”‚  â”‚              â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                        â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  å‘Šè­¦è°ƒåº¦å™¨  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   å‘Šè­¦äº‹ä»¶  â”‚            â”‚
â”‚  â”‚              â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                        â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ USDè½¬æ¢å™¨    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  è½¬æ¢è¯·æ±‚   â”‚            â”‚
â”‚  â”‚              â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    ç›‘æ§      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  é”™è¯¯æ¢å¤    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  é”™è¯¯äº‹ä»¶    â”‚            â”‚
â”‚  â”‚  ç®¡ç†å™¨      â”‚              â”‚             â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. äº‹ä»¶é©±åŠ¨è®¾è®¡

**è®¾è®¡åŸåˆ™**:
- å¼‚æ­¥éé˜»å¡å¤„ç†
- æ¾è€¦åˆç»„ä»¶
- äº‹ä»¶æ€»çº¿é€šä¿¡
- å¯æ‰©å±•æ¶æ„

**äº‹ä»¶ç±»å‹**:
1. `TradeEvent` - äº¤æ˜“äº‹ä»¶
2. `AggregationRequest` - èšåˆè¯·æ±‚
3. `ThresholdCheck` - é˜ˆå€¼æ£€æŸ¥
4. `AlertEvent` - å‘Šè­¦äº‹ä»¶
5. `ConvertRequest` - è½¬æ¢è¯·æ±‚
6. `ErrorEvent` - é”™è¯¯äº‹ä»¶

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. WebSocketç®¡ç†å™¨ (BinanceWebSocketClient)

#### ç±»è®¾è®¡
```python
class BinanceWebSocketClient(BaseExchangeCollector):
    """
    å¸å®‰WebSocketå®¢æˆ·ç«¯
    è´Ÿè´£å®æ—¶æ•°æ®è·å–å’Œäº‹ä»¶åˆ†å‘
    """
    def __init__(self, symbols: List[str]):
        self.websocket_url: str = "wss://stream.binance.com:9443/ws"
        self.symbols: List[str] = symbols
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.connection_state: ConnectionState = ConnectionState.DISCONNECTED
        self.recovery: ErrorRecoveryManager = ErrorRecoveryManager()
        self.price_converter: PriceConverter = PriceConverter()
        self.subscriptions: Dict[str, str] = {}  # stream_name -> symbol
        self._tasks: List[asyncio.Task] = []
        self.stats: Dict[str, Any] = {
            "trades_received": 0,
            "trades_per_second": 0.0,
            "last_trade_time": None,
            "connection_uptime": 0.0
        }
```

#### å…³é”®æ–¹æ³•

**start()**
```python
async def start(self) -> None:
    """å¯åŠ¨WebSocketè¿æ¥å’Œè®¢é˜…"""
    1. æ›´æ–°çŠ¶æ€ä¸ºCONNECTING
    2. å»ºç«‹WebSocketè¿æ¥
    3. è®¢é˜…æ‰€æœ‰äº¤æ˜“å¯¹
    4. å¯åŠ¨æ¶ˆæ¯å¤„ç†ä»»åŠ¡
    5. æ›´æ–°çŠ¶æ€ä¸ºCONNECTED
```

**_message_handler()**
```python
async def _message_handler(self) -> None:
    """å¼‚æ­¥å¤„ç†WebSocketæ¶ˆæ¯"""
    while self.connection_state == ConnectionState.CONNECTED:
        try:
            message = await self.websocket.recv()
            data = json.loads(message)
            await self._process_message(data)
        except ConnectionClosed:
            await self.recovery.handle_disconnection()
        except Exception as e:
            logger.error(f"æ¶ˆæ¯å¤„ç†é”™è¯¯: {e}")
```

**è®¾è®¡è¦ç‚¹**:
- ä½¿ç”¨`asyncio`å®ç°å¼‚æ­¥I/O
- è‡ªåŠ¨é‡è¿æœºåˆ¶ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
- äº‹ä»¶å›è°ƒé€šçŸ¥å…¶ä»–ç»„ä»¶
- ç»Ÿè®¡æ•°æ®å®æ—¶æ›´æ–°

#### é‡è¿ç­–ç•¥
```python
class ErrorRecoveryManager:
    """
    é”™è¯¯æ¢å¤ç®¡ç†å™¨
    å®ç°æŒ‡æ•°é€€é¿é‡è¿ç­–ç•¥
    """
    def __init__(self):
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.base_backoff = 2.0  # 2ç§’
        self.max_backoff = 300.0  # 5åˆ†é’Ÿ
        self.critical_error_threshold = 3

    async def reconnect(self) -> bool:
        """æ‰§è¡Œé‡è¿"""
        backoff = min(
            self.base_backoff * (2 ** self.reconnect_attempts),
            self.max_backoff
        )
        await asyncio.sleep(backoff)
        self.reconnect_attempts += 1
        return self.reconnect_attempts <= self.max_reconnect_attempts
```

### 2. è®¢å•èšåˆå™¨ (OrderAggregator)

#### ç±»è®¾è®¡
```python
class OrderAggregator:
    """
    5åˆ†é’Ÿæ»šåŠ¨çª—å£èšåˆå™¨
    è´Ÿè´£å®æ—¶èšåˆäº¤æ˜“æ•°æ®
    """
    def __init__(self, window_minutes: int = 5):
        self.window_size_ms: int = window_minutes * 60 * 1000
        self.data: Dict[str, List[TradeRecord]] = defaultdict(list)
        self.lock: Lock = Lock()
        self.threshold_usd: float = 2_000_000
        self.stats: Dict[str, Any] = {
            "trades_received": 0,
            "trades_pruned": 0,
            "window_calculations": 0,
            "threshold_breaches": 0
        }
```

#### æ•°æ®ç»“æ„
```python
@dataclass
class TradeRecord:
    """äº¤æ˜“è®°å½•"""
    symbol: str
    amount: float  # USDä»·å€¼
    side: str  # BUY/SELL
    timestamp: int  # æ¯«ç§’
    trade_id: int
    price: float
    quantity: float
```

#### å…³é”®æ–¹æ³•

**add_trade()**
```python
async def add_trade(self, trade_event: TradeEvent, usd_value: float) -> None:
    """æ·»åŠ äº¤æ˜“åˆ°èšåˆå™¨"""
    with self.lock:
        # åˆ›å»ºäº¤æ˜“è®°å½•
        record = TradeRecord(
            symbol=trade_event.symbol,
            amount=usd_value,
            side=trade_event.side,
            timestamp=trade_event.timestamp,
            trade_id=trade_event.trade_id,
            price=trade_event.price,
            quantity=trade_event.quantity
        )

        # æ·»åŠ åˆ°æ•°æ®å­˜å‚¨
        self.data[trade_event.symbol].append(record)

        # ç«‹å³æ¸…ç†è¿‡æœŸæ•°æ®
        self._prune_old_trades(trade_event.symbol, trade_event.timestamp)

        # æ›´æ–°ç»Ÿè®¡
        self.stats["trades_received"] += 1
```

**_prune_old_trades()**
```python
def _prune_old_trades(self, symbol: str, current_time_ms: int) -> None:
    """æ¸…ç†è¿‡æœŸäº¤æ˜“æ•°æ®"""
    cutoff_time = current_time_ms - self.window_size_ms
    trades = self.data[symbol]

    # ä¿ç•™çª—å£å†…çš„äº¤æ˜“
    self.data[symbol] = [t for t in trades if t.timestamp > cutoff_time]

    # ç»Ÿè®¡æ¸…ç†çš„æ•°é‡
    pruned = len(trades) - len(self.data[symbol])
    if pruned > 0:
        self.stats["trades_pruned"] += pruned
```

**get_aggregation()**
```python
async def get_aggregation(self, symbol: str, current_time_ms: int) -> Dict[str, Any]:
    """è·å–èšåˆç»“æœ"""
    with self.lock:
        self.stats["window_calculations"] += 1

        if symbol not in self.data:
            return self._empty_result()

        # æ¸…ç†è¿‡æœŸæ•°æ®
        self._prune_old_trades(symbol, current_time_ms)

        # è®¡ç®—èšåˆ
        trades = self.data[symbol]
        buy_volume = sum(t.amount for t in trades if t.side == "BUY")
        sell_volume = sum(t.amount for t in trades if t.side == "SELL")
        total_volume = buy_volume + sell_volume
        trade_count = len(trades)

        # æ£€æŸ¥é˜ˆå€¼çªç ´
        threshold_breach = total_volume >= self.threshold_usd
        if threshold_breach:
            self.stats["threshold_breaches"] += 1

        return {
            "symbol": symbol,
            "window_minutes": 5,
            "total_volume": total_volume,
            "buy_volume": buy_volume,
            "sell_volume": sell_volume,
            "trade_count": trade_count,
            "threshold_breach": threshold_breach,
            "threshold_usd": self.threshold_usd
        }
```

**è®¾è®¡è¦ç‚¹**:
- çº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨Lockï¼‰
- å®æ—¶æ•°æ®æ¸…ç†ï¼ˆé¿å…å†…å­˜æ³„æ¼ï¼‰
- ä¸€æ¬¡è®¡ç®—å¤šä¸ªæŒ‡æ ‡
- æ”¯æŒåŠ¨æ€é˜ˆå€¼æ›´æ–°

#### å†…å­˜ä¼˜åŒ–ç­–ç•¥
1. **å®æ—¶æ¸…ç†**: æ¯æ¬¡æ·»åŠ äº¤æ˜“æ—¶ç«‹å³æ¸…ç†è¿‡æœŸæ•°æ®
2. **æ•°æ®ç»“æ„ä¼˜åŒ–**: ä½¿ç”¨dequeä»£æ›¿listï¼ˆå¦‚æœéœ€è¦ï¼‰
3. **å»é‡æœºåˆ¶**: åŸºäºtrade_idå»é‡
4. **åˆ†æ¡¶å­˜å‚¨**: æŒ‰äº¤æ˜“å¯¹åˆ†æ¡¶å‡å°‘æœç´¢

### 3. é˜ˆå€¼æ£€æµ‹å¼•æ“ (ThresholdEngine)

#### ç±»è®¾è®¡
```python
class ThresholdEngine:
    """
    é˜ˆå€¼æ£€æµ‹å¼•æ“
    è´Ÿè´£æ£€æµ‹èšåˆæ•°æ®å¹¶è§¦å‘å‘Šè­¦
    """
    def __init__(self, threshold_usd: float = 2_000_000, cooldown_minutes: int = 5):
        self.threshold_usd: float = threshold_usd
        self.cooldown_minutes: int = cooldown_minutes
        self.cooldowns: Dict[str, datetime] = {}
        self.alert_callback: Optional[Callable] = None
        self.stats: Dict[str, Any] = {
            "threshold_checks": 0,
            "alerts_triggered": 0,
            "alerts_suppressed": 0,
            "cooldowns_active": 0
        }
```

#### å…³é”®æ–¹æ³•

**check_aggregation()**
```python
async def check_aggregation(self, symbol: str, aggregation_data: Dict) -> Optional[ThresholdEvent]:
    """æ£€æŸ¥èšåˆæ•°æ®æ˜¯å¦çªç ´é˜ˆå€¼"""
    self.stats["threshold_checks"] += 1

    # æ£€æŸ¥é˜ˆå€¼
    if not aggregation_data.get("threshold_breach", False):
        return None

    # è·å–èšåˆä¿¡æ¯
    total_volume = aggregation_data.get("total_volume", 0.0)
    buy_volume = aggregation_data.get("buy_volume", 0.0)
    sell_volume = aggregation_data.get("sell_volume", 0.0)
    trade_count = aggregation_data.get("trade_count", 0)

    # å†³å®šä¸»è¦æ–¹å‘
    direction = self._determine_direction(buy_volume, sell_volume)

    # æ£€æŸ¥å†·å´
    if await self._is_in_cooldown(symbol):
        self.stats["alerts_suppressed"] += 1
        return None

    # åˆ›å»ºé˜ˆå€¼äº‹ä»¶
    event = ThresholdEvent(
        symbol=symbol,
        direction=direction,
        total_volume=total_volume,
        buy_volume=buy_volume,
        sell_volume=sell_volume,
        trade_count=trade_count,
        threshold_usd=self.threshold_usd,
        window_minutes=aggregation_data.get("window_minutes", 5),
        timestamp=datetime.now()
    )

    # è®¾ç½®å†·å´
    await self._set_cooldown(symbol)

    # è§¦å‘å‘Šè­¦
    self.stats["alerts_triggered"] += 1
    if self.alert_callback:
        if asyncio.iscoroutinefunction(self.alert_callback):
            await self.alert_callback(event)
        else:
            self.alert_callback(event)

    return event
```

**_determine_direction()**
```python
def _determine_direction(self, buy_volume: float, sell_volume: float) -> str:
    """æ™ºèƒ½åˆ¤æ–­äº¤æ˜“æ–¹å‘"""
    diff_ratio = abs(buy_volume - sell_volume) / max(buy_volume + sell_volume, 1)

    # å¦‚æœä¹°å–å·®è·å°äº10%ï¼Œè®¤ä¸ºæ˜¯åŒå‘
    if diff_ratio < 0.1:
        return "åŒå‘"

    return "ä¹°å…¥" if buy_volume > sell_volume else "å–å‡º"
```

**_is_in_cooldown()**
```python
async def _is_in_cooldown(self, symbol: str) -> bool:
    """æ£€æŸ¥æ˜¯å¦åœ¨å†·å´æœŸ"""
    if symbol not in self.cooldowns:
        return False

    cooldown_until = self.cooldowns[symbol]
    return datetime.now() < cooldown_until
```

**_set_cooldown()**
```python
async def _set_cooldown(self, symbol: str) -> None:
    """è®¾ç½®å†·å´æ—¶é—´"""
    self.cooldowns[symbol] = datetime.now() + timedelta(minutes=self.cooldown_minutes)
    self.stats["cooldowns_active"] = len(self.cooldowns)
```

**è®¾è®¡è¦ç‚¹**:
- å¼‚æ­¥å›è°ƒæ”¯æŒ
- æ™ºèƒ½æ–¹å‘åˆ¤æ–­
- ç‹¬ç«‹å†·å´ç®¡ç†
- ç»Ÿè®¡æ•°æ®æ”¶é›†

### 4. USDè½¬æ¢å™¨ (PriceConverter)

#### ç±»è®¾è®¡
```python
class PriceConverter:
    """
    USDè½¬æ¢å™¨
    è´Ÿè´£å°†å„ç§è´§å¸è½¬æ¢ä¸ºUSD
    """
    def __init__(self):
        self.supported_stablecoins: Set[str] = {
            "USDT", "USDC", "BUSD", "FDUSD", "TUSD", "USDP"
        }
        self.cache: Dict[str, Tuple[float, datetime]] = {}
        self.cache_ttl: int = 60  # 60ç§’
        self.lock: Lock = Lock()
        self.stats: Dict[str, Any] = {
            "conversions": 0,
            "cache_hits": 0,
            "api_calls": 0
        }
```

#### å…³é”®æ–¹æ³•

**convert_to_usd()**
```python
async def convert_to_usd(self, symbol: str, price: float, quantity: float) -> float:
    """è½¬æ¢äº¤æ˜“ä¸ºUSDä»·å€¼"""
    self.stats["conversions"] += 1

    # è·å–æŠ¥ä»·è´§å¸ (å¦‚USDT, BTCç­‰)
    quote_currency = self._extract_quote_currency(symbol)

    # å¦‚æœå·²ç»æ˜¯USDæˆ–ç¨³å®šå¸ï¼Œç›´æ¥è®¡ç®—
    if quote_currency in self.supported_stablecoins or quote_currency == "USD":
        return price * quantity

    # è·å–USDæ±‡ç‡
    usd_rate = await self._get_usd_rate(quote_currency)

    # è®¡ç®—USDä»·å€¼
    usd_value = price * quantity * usd_rate

    return usd_value
```

**_extract_quote_currency()**
```python
def _extract_quote_currency(self, symbol: str) -> str:
    """ä»äº¤æ˜“å¯¹ä¸­æå–æŠ¥ä»·è´§å¸"""
    # BTCUSDT -> USDT
    # ETHBTC -> BTC
    if len(symbol) == 6:
        return symbol[-4:]  # ç®€å•çš„6å­—ç¬¦äº¤æ˜“å¯¹
    else:
        # å¤„ç†æ›´å¤æ‚çš„äº¤æ˜“å¯¹
        for stablecoin in sorted(self.supported_stablecoins, key=len, reverse=True):
            if symbol.endswith(stablecoin):
                return stablecoin
        return symbol[-4:]  # é»˜è®¤è¿”å›å4ä½
```

**_get_usd_rate()**
```python
async def _get_usd_rate(self, currency: str) -> float:
    """è·å–è´§å¸å¯¹USDçš„æ±‡ç‡"""
    with self.lock:
        # æ£€æŸ¥ç¼“å­˜
        if currency in self.cache:
            rate, timestamp = self.cache[currency]
            if (datetime.now() - timestamp).total_seconds() < self.cache_ttl:
                self.stats["cache_hits"] += 1
                return rate

        # è·å–æ–°æ±‡ç‡
        rate = await self._fetch_usd_rate(currency)

        # æ›´æ–°ç¼“å­˜
        self.cache[currency] = (rate, datetime.now())

        return rate
```

**_fetch_usd_rate()**
```python
async def _fetch_usd_rate(self, currency: str) -> float:
    """ä»Binance APIè·å–æ±‡ç‡"""
    self.stats["api_calls"] += 1

    # å°è¯•å¤šç§äº¤æ˜“å¯¹è·å–æ±‡ç‡
    pairs = [f"{currency}USDT", f"{currency}BUSD", f"USDT{currency}"]

    for pair in pairs:
        try:
            url = f"https://api.binance.com/api/v3/ticker/price?symbol={pair}"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        data = await response.json()
                        price = float(data["price"])

                        # å¦‚æœæ˜¯åå‘äº¤æ˜“å¯¹ (å¦‚USDTBTC)ï¼Œå–å€’æ•°
                        if pair.startswith("USDT"):
                            return 1.0 / price if price > 0 else 1.0

                        return price
        except Exception as e:
            logger.debug(f"è·å– {pair} æ±‡ç‡å¤±è´¥: {e}")
            continue

    # æ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œè¿”å›é»˜è®¤å€¼
    logger.warning(f"æ— æ³•è·å– {currency} çš„USDæ±‡ç‡ï¼Œä½¿ç”¨é»˜è®¤å€¼1.0")
    return 1.0
```

**è®¾è®¡è¦ç‚¹**:
- å¤šå±‚ç¼“å­˜æœºåˆ¶
- æ”¯æŒå¤šç§ç¨³å®šå¸
- å®¹é”™å’Œé™çº§ç­–ç•¥
- æ€§èƒ½ç»Ÿè®¡è¿½è¸ª

### 5. å‘Šè­¦è°ƒåº¦å™¨ (AlertDispatcher)

#### ç±»è®¾è®¡
```python
class AlertDispatcher:
    """
    å‘Šè­¦è°ƒåº¦å™¨
    è´Ÿè´£æ ¼å¼åŒ–ã€é˜Ÿåˆ—ç®¡ç†å’Œå‘é€å‘Šè­¦
    """
    def __init__(self, telegram_bot, rate_limit_per_minute: int = 12):
        self.telegram_bot = telegram_bot
        self.rate_limiter: RateLimiter = RateLimiter(rate_limit_per_minute)
        self.alert_queue: asyncio.Queue = asyncio.Queue(maxsize=1000)
        self.running: bool = False
        self.worker_task: Optional[asyncio.Task] = None
        self.stats: Dict[str, Any] = {
            "alerts_queued": 0,
            "alerts_sent": 0,
            "alerts_failed": 0,
            "queue_size": 0
        }
```

#### å…³é”®æ–¹æ³•

**dispatch_alert()**
```python
async def dispatch_alert(self, alert: LargeOrderAlert) -> bool:
    """åˆ†å‘å‘Šè­¦åˆ°é˜Ÿåˆ—"""
    try:
        # æ£€æŸ¥é€Ÿç‡é™åˆ¶
        if not self.rate_limiter.acquire():
            logger.warning("å‘Šè­¦é€Ÿç‡é™åˆ¶è§¦å‘")
            return False

        # æ·»åŠ åˆ°é˜Ÿåˆ—
        await self.alert_queue.put(alert)
        self.stats["alerts_queued"] += 1
        self.stats["queue_size"] = self.alert_queue.qsize()

        return True

    except asyncio.QueueFull:
        logger.error("å‘Šè­¦é˜Ÿåˆ—å·²æ»¡")
        self.stats["alerts_failed"] += 1
        return False
```

**_process_queue()**
```python
async def _process_queue(self) -> None:
    """å¤„ç†å‘Šè­¦é˜Ÿåˆ—"""
    self.running = True

    while self.running:
        try:
            # ä»é˜Ÿåˆ—è·å–å‘Šè­¦
            alert = await asyncio.wait_for(
                self.alert_queue.get(),
                timeout=1.0
            )

            # å‘é€å‘Šè­¦
            success = await self._send_alert(alert)

            if success:
                self.stats["alerts_sent"] += 1
            else:
                self.stats["alerts_failed"] += 1

            # æ›´æ–°é˜Ÿåˆ—å¤§å°
            self.stats["queue_size"] = self.alert_queue.qsize()

        except asyncio.TimeoutError:
            # è¶…æ—¶æ­£å¸¸ï¼Œç»§ç»­å¾ªç¯
            continue
        except Exception as e:
            logger.error(f"å¤„ç†å‘Šè­¦é˜Ÿåˆ—é”™è¯¯: {e}")
            await asyncio.sleep(1)
```

**_send_alert()**
```python
async def _send_alert(self, alert: LargeOrderAlert) -> bool:
    """å‘é€å‘Šè­¦åˆ°Telegram"""
    try:
        # æ ¼å¼åŒ–æ¶ˆæ¯
        message = self._format_alert_message(alert)

        # è·å–ç™½åå•ç”¨æˆ·
        from src.user_configuration import get_whitelist
        whitelisted_users = get_whitelist()

        if not whitelisted_users:
            logger.warning("æ²¡æœ‰ç™½åå•ç”¨æˆ·")
            return False

        # å‘é€å‘Šè­¦åˆ°æ‰€æœ‰ç”¨æˆ·
        success_count = 0
        fail_count = 0

        for user_id in whitelisted_users:
            try:
                self.telegram_bot.send_message(
                    chat_id=user_id,
                    text=message,
                    parse_mode="Markdown"
                )
                success_count += 1

                # å°å»¶è¿Ÿé˜²æ­¢é€Ÿç‡é™åˆ¶
                await asyncio.sleep(0.05)

            except Exception as e:
                fail_count += 1
                logger.error(f"å‘é€å‘Šè­¦åˆ°ç”¨æˆ· {user_id} å¤±è´¥: {e}")

        logger.info(
            f"å¤§é¢äº¤æ˜“å‘Šè­¦å·²å‘é€: {alert.symbol}-{alert.direction} "
            f"${alert.total_volume:,.0f}. "
            f"æˆåŠŸ: {success_count}, å¤±è´¥: {fail_count}"
        )

        return success_count > 0

    except Exception as e:
        logger.error(f"å‘é€å‘Šè­¦é”™è¯¯: {e}", exc_info=True)
        return False
```

**_format_alert_message()**
```python
def _format_alert_message(self, alert: LargeOrderAlert) -> str:
    """æ ¼å¼åŒ–å‘Šè­¦æ¶ˆæ¯"""
    direction_emoji = "ğŸ“ˆ" if alert.direction == "ä¹°å…¥" else "ğŸ“‰" if alert.direction == "å–å‡º" else "âš–ï¸"

    message = f"""`[å¤§é¢äº¤æ˜“] {alert.symbol}`
{direction_emoji} æ–¹å‘ï¼š{alert.direction}
ğŸ’° é‡‘é¢ï¼š${alert.total_volume:,.0f}
ğŸ“Š ä¹°å…¥ï¼š${alert.buy_volume:,.0f}
ğŸ“Š å–å‡ºï¼š${alert.sell_volume:,.0f}
ğŸ• æ—¶é—´ï¼š{alert.timestamp.strftime('%H:%M:%S')}
â±ï¸ çª—å£ï¼š{alert.window_minutes}åˆ†é’Ÿ
ğŸ”¢ äº¤æ˜“æ•°ï¼š{alert.trade_count}ç¬”
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
é˜ˆå€¼ï¼š${alert.threshold_usd:,.0f} | äº¤æ˜“æ‰€ï¼š{alert.exchange}`"""

    return message
```

**è®¾è®¡è¦ç‚¹**:
- å¼‚æ­¥é˜Ÿåˆ—å¤„ç†
- é€Ÿç‡é™åˆ¶ä¿æŠ¤
- æ‰¹é‡å‘é€ä¼˜åŒ–
- å¤±è´¥é‡è¯•æœºåˆ¶

---

## ğŸ”„ äº‹ä»¶æµè®¾è®¡

### 1. äº¤æ˜“äº‹ä»¶æµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Binance WebSocket    â”‚
â”‚     å‘é€äº¤æ˜“æ•°æ®     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è§£æäº¤æ˜“æ•°æ®     â”‚
â”‚  åˆ›å»ºTradeEvent  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  USDä»·å€¼è½¬æ¢     â”‚
â”‚  PriceConverter  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ·»åŠ åˆ°èšåˆå™¨     â”‚
â”‚ OrderAggregator  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è·å–èšåˆç»“æœ     â”‚
â”‚  æ£€æŸ¥é˜ˆå€¼çªç ´     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ£€æŸ¥å†·å´æ—¶é—´     â”‚
â”‚ ThresholdEngine  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åˆ›å»ºå‘Šè­¦äº‹ä»¶     â”‚
â”‚  å‘é€å‘Šè­¦æ¶ˆæ¯     â”‚
â”‚ AlertDispatcher  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. é”™è¯¯æ¢å¤æµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WebSocketæ–­å¼€   â”‚
â”‚  è¿æ¥é”™è¯¯         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ£€æµ‹é”™è¯¯ç±»å‹     â”‚
â”‚ ErrorRecovery    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚å¯æ¢å¤  â”‚  â”‚ä¸¥é‡   â”‚
â”‚é”™è¯¯    â”‚  â”‚é”™è¯¯   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚         â”‚
     â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ‰§è¡Œé‡è¿       â”‚
â”‚æŒ‡æ•°é€€é¿ç­–ç•¥     â”‚
â”‚  æ¢å¤è¿æ¥       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é‡æ–°è®¢é˜…       â”‚
â”‚  æ¢å¤ç›‘æ§       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä¼˜åŒ–

#### ç­–ç•¥1: å®æ—¶æ•°æ®æ¸…ç†
```python
def _prune_old_trades(self, symbol: str, current_time_ms: int):
    """æ¯æ¬¡æ·»åŠ äº¤æ˜“æ—¶ç«‹å³æ¸…ç†è¿‡æœŸæ•°æ®"""
    cutoff_time = current_time_ms - self.window_size_ms
    # åªä¿ç•™çª—å£å†…çš„æ•°æ®
    self.data[symbol] = [t for t in self.data[symbol] if t.timestamp > cutoff_time]
```

#### ç­–ç•¥2: å»é‡æœºåˆ¶
```python
def _add_trade_with_dedup(self, trade: TradeRecord):
    """åŸºäºtrade_idå»é‡"""
    existing_trades = self.data[trade.symbol]
    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if any(t.trade_id == trade.trade_id for t in existing_trades):
        return  # è·³è¿‡é‡å¤äº¤æ˜“
    existing_trades.append(trade)
```

#### ç­–ç•¥3: å‹ç¼©å­˜å‚¨
```python
# ä½¿ç”¨æ›´ç´§å‡‘çš„æ•°æ®ç»“æ„
from collections import deque

# dequeæ¯”listæ›´èŠ‚çœå†…å­˜ï¼Œä¸”append/popé«˜æ•ˆ
self.data[symbol] = deque(maxlen=10000)  # è®¾ç½®æœ€å¤§é•¿åº¦
```

### 2. CPUä¼˜åŒ–

#### ç­–ç•¥1: å¼‚æ­¥I/O
```python
# æ‰€æœ‰I/Oæ“ä½œéƒ½ä½¿ç”¨async/await
async def fetch_price(self, symbol: str) -> float:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()
```

#### ç­–ç•¥2: æ‰¹é‡å¤„ç†
```python
async def batch_convert(self, conversions: List[ConversionRequest]) -> List[float]:
    """æ‰¹é‡è½¬æ¢ï¼Œå‡å°‘APIè°ƒç”¨æ¬¡æ•°"""
    # åˆå¹¶ç›¸åŒè´§å¸çš„è¯·æ±‚
    currency_groups = defaultdict(list)
    for req in conversions:
        currency_groups[req.currency].append(req)

    # æ‰¹é‡æŸ¥è¯¢
    results = []
    for currency, reqs in currency_groups.items():
        rate = await self._get_usd_rate(currency)
        for req in reqs:
            results.append(req.amount * rate)

    return results
```

#### ç­–ç•¥3: ç¼“å­˜ä¼˜åŒ–
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_symbol_info(symbol: str) -> SymbolInfo:
    """ç¼“å­˜äº¤æ˜“å¯¹ä¿¡æ¯"""
    return self._fetch_symbol_info(symbol)
```

### 3. ç½‘ç»œä¼˜åŒ–

#### ç­–ç•¥1: è¿æ¥å¤ç”¨
```python
class BinanceWebSocketClient:
    def __init__(self):
        # å¤ç”¨WebSocketè¿æ¥
        self.session = aiohttp.ClientSession(
            connector=aiohttp.TCPConnector(limit=100)
        )
```

#### ç­–ç•¥2: å¿ƒè·³æœºåˆ¶
```python
async def _ping_handler(self):
    """å®šæœŸå‘é€pingä¿æŒè¿æ¥"""
    while self.connected:
        try:
            await self.websocket.ping()
            await asyncio.sleep(30)  # 30ç§’pingä¸€æ¬¡
        except Exception as e:
            logger.error(f"Pingå¤±è´¥: {e}")
            break
```

#### ç­–ç•¥3: æ‰¹é‡è®¢é˜…
```python
# ä¸€æ¬¡æ€§è®¢é˜…æ‰€æœ‰äº¤æ˜“å¯¹
streams = [f"{symbol.lower()}@trade" for symbol in self.symbols]
subscribe_msg = {
    "method": "SUBSCRIBE",
    "params": streams,
    "id": int(time.time())
}
```

---

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†è®¾è®¡

### 1. é”™è¯¯åˆ†ç±»

```python
class ErrorSeverity(Enum):
    LOW = 1      # å¯å¿½ç•¥ï¼Œè®°å½•æ—¥å¿—
    MEDIUM = 2   # é‡è¯•ä¸€æ¬¡
    HIGH = 3     # æŒ‡æ•°é€€é¿é‡è¯•
    CRITICAL = 4 # ç«‹å³å‘Šè­¦ç®¡ç†å‘˜
```

### 2. é”™è¯¯æ¢å¤ç­–ç•¥

```python
class ErrorRecoveryManager:
    """
    é”™è¯¯æ¢å¤ç®¡ç†å™¨
    """
    def __init__(self):
        self.error_counts = defaultdict(int)
        self.last_error_time = {}
        self.error_threshold = 5  # 5æ¬¡é”™è¯¯åè®¤ä¸ºä¸¥é‡

    async def handle_error(self, error: Exception, context: str) -> bool:
        """å¤„ç†é”™è¯¯å¹¶å†³å®šæ¢å¤ç­–ç•¥"""
        error_type = self._classify_error(error)

        if error_type == ErrorSeverity.LOW:
            logger.warning(f"ä½ä¼˜å…ˆçº§é”™è¯¯ ({context}): {error}")
            return True

        elif error_type == ErrorSeverity.MEDIUM:
            await asyncio.sleep(1)
            return True

        elif error_type == ErrorSeverity.HIGH:
            return await self._exponential_backoff_retry(context)

        else:  # CRITICAL
            await self._send_admin_alert(error, context)
            return False

    def _classify_error(self, error: Exception) -> ErrorSeverity:
        """åˆ†ç±»é”™è¯¯ç±»å‹"""
        if isinstance(error, ConnectionError):
            return ErrorSeverity.HIGH
        elif isinstance(error, TimeoutError):
            return ErrorSeverity.MEDIUM
        elif isinstance(error, ValueError):
            return ErrorSeverity.LOW
        else:
            return ErrorSeverity.HIGH
```

### 3. é™çº§ç­–ç•¥

```python
async def convert_to_usd(self, symbol: str, price: float, quantity: float) -> float:
    """USDè½¬æ¢é™çº§ç­–ç•¥"""
    try:
        # å°è¯•å®æ—¶è½¬æ¢
        return await self._convert_with_live_rate(symbol, price, quantity)
    except Exception as e:
        logger.warning(f"å®æ—¶è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜: {e}")
        try:
            # å°è¯•ä½¿ç”¨ç¼“å­˜
            return await self._convert_with_cache(symbol, price, quantity)
        except Exception as e:
            logger.warning(f"ç¼“å­˜è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: {e}")
            # ä½¿ç”¨é»˜è®¤å€¼ï¼š1.0ï¼ˆå‡è®¾å·²ç»æ˜¯USDï¼‰
            return price * quantity
```

---

## ğŸ“ˆ ç›‘æ§ä¸æŒ‡æ ‡

### 1. å…³é”®æ€§èƒ½æŒ‡æ ‡ (KPI)

```python
@dataclass
class PerformanceMetrics:
    """æ€§èƒ½æŒ‡æ ‡"""
    # WebSocketæŒ‡æ ‡
    ws_connections_total: int = 0
    ws_disconnections_total: int = 0
    ws_reconnects_total: int = 0
    ws_uptime_seconds: float = 0.0

    # äº¤æ˜“å¤„ç†æŒ‡æ ‡
    trades_received_total: int = 0
    trades_processed_total: int = 0
    trades_per_second: float = 0.0

    # å‘Šè­¦æŒ‡æ ‡
    alerts_triggered_total: int = 0
    alerts_suppressed_total: int = 0
    alerts_sent_total: int = 0
    alerts_failed_total: int = 0

    # èµ„æºä½¿ç”¨æŒ‡æ ‡
    cpu_usage_percent: float = 0.0
    memory_usage_mb: float = 0.0
    queue_size: int = 0

    # é”™è¯¯æŒ‡æ ‡
    errors_total: int = 0
    critical_errors_total: int = 0
```

### 2. æŒ‡æ ‡æ”¶é›†

```python
class MetricsCollector:
    """
    æŒ‡æ ‡æ”¶é›†å™¨
    """
    def __init__(self):
        self.metrics = PerformanceMetrics()
        self.lock = Lock()

    def update_metric(self, metric_name: str, value: float):
        """æ›´æ–°æŒ‡æ ‡"""
        with self.lock:
            if hasattr(self.metrics, metric_name):
                setattr(self.metrics, metric_name, value)

    def increment_counter(self, counter_name: str, amount: int = 1):
        """å¢åŠ è®¡æ•°å™¨"""
        with self.lock:
            if hasattr(self.metrics, counter_name):
                current = getattr(self.metrics, counter_name)
                setattr(self.metrics, counter_name, current + amount)
```

### 3. å¥åº·æ£€æŸ¥

```python
async def health_check(self) -> Dict[str, Any]:
    """å¥åº·æ£€æŸ¥"""
    return {
        "status": "healthy" if self._is_healthy() else "unhealthy",
        "timestamp": datetime.now().isoformat(),
        "uptime_seconds": self.get_uptime(),
        "websocket": {
            "connected": self.connected,
            "reconnects": self.recovery.reconnect_attempts
        },
        "alerts": {
            "queued": self.alert_queue.qsize(),
            "sent_last_hour": self.stats["alerts_sent"]
        },
        "resources": {
            "cpu_percent": psutil.cpu_percent(),
            "memory_mb": psutil.virtual_memory().used / 1024 / 1024
        }
    }
```

---

## ğŸ” å®‰å…¨æ€§è®¾è®¡

### 1. è¾“å…¥éªŒè¯

```python
def validate_trade_event(self, data: Dict) -> Optional[TradeEvent]:
    """éªŒè¯äº¤æ˜“äº‹ä»¶æ•°æ®"""
    required_fields = ["s", "p", "q", "T", "m"]  # symbol, price, qty, time, isBuyerMaker

    # æ£€æŸ¥å¿…éœ€å­—æ®µ
    for field in required_fields:
        if field not in data:
            logger.warning(f"ç¼ºå°‘å­—æ®µ: {field}")
            return None

    # ç±»å‹éªŒè¯
    try:
        return TradeEvent(
            symbol=data["s"],
            price=float(data["p"]),
            quantity=float(data["q"]),
            timestamp=int(data["T"]),
            is_buyer_mark=data["m"]
        )
    except (ValueError, TypeError) as e:
        logger.warning(f"æ•°æ®ç±»å‹é”™è¯¯: {e}")
        return None
```

### 2. é€Ÿç‡é™åˆ¶

```python
class RateLimiter:
    """
    é€Ÿç‡é™åˆ¶å™¨
    ä»¤ç‰Œæ¡¶ç®—æ³•
    """
    def __init__(self, rate: int, per_seconds: int = 60):
        self.rate = rate
        self.per_seconds = per_seconds
        self.tokens = rate
        self.last_update = time.time()
        self.lock = Lock()

    def acquire(self) -> bool:
        """è·å–ä»¤ç‰Œ"""
        with self.lock:
            now = time.time()
            elapsed = now - self.last_update

            # æ·»åŠ ä»¤ç‰Œ
            self.tokens = min(
                self.rate,
                self.tokens + elapsed * self.rate / self.per_seconds
            )
            self.last_update = now

            # æ£€æŸ¥æ˜¯å¦æœ‰ä»¤ç‰Œ
            if self.tokens >= 1:
                self.tokens -= 1
                return True
            return False
```

### 3. æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

```python
# éšè—æ•æ„Ÿä¿¡æ¯
def sanitize_message(self, message: str) -> str:
    """æ¸…ç†æ•æ„Ÿä¿¡æ¯"""
    # ç§»é™¤å¯èƒ½çš„APIå¯†é’¥
    message = re.sub(r'[a-zA-Z0-9]{32,}', '***', message)
    # ç§»é™¤å¯èƒ½çš„ä»¤ç‰Œ
    message = re.sub(r'Bearer\s+[a-zA-Z0-9\-_]+', 'Bearer ***', message)
    return message

# å®‰å…¨æ—¥å¿—
def log_error(self, error: Exception, context: str):
    """å®‰å…¨è®°å½•é”™è¯¯æ—¥å¿—"""
    safe_error = str(error)[:200]  # é™åˆ¶é•¿åº¦
    logger.error(
        f"[{context}] é”™è¯¯: {safe_error}",
        extra={
            "error_type": type(error).__name__,
            "context": context,
            "sanitized": True
        }
    )
```

---

## ğŸ§ª æµ‹è¯•è®¾è®¡

### 1. å•å…ƒæµ‹è¯•ç­–ç•¥

```python
class TestOrderAggregator:
    """è®¢å•èšåˆå™¨æµ‹è¯•"""

    def test_add_trade(self):
        """æµ‹è¯•æ·»åŠ äº¤æ˜“"""
        aggregator = OrderAggregator(window_minutes=5)

        # åˆ›å»ºæµ‹è¯•äº¤æ˜“
        trade = TradeEvent(
            symbol="BTCUSDT",
            price=50000,
            quantity=10,
            timestamp=time.time() * 1000,
            is_buyer_mark=True
        )

        # æ·»åŠ äº¤æ˜“
        asyncio.run(aggregator.add_trade(trade, 500000))

        # éªŒè¯èšåˆç»“æœ
        result = asyncio.run(aggregator.get_aggregation("BTCUSDT", time.time() * 1000))
        assert result["total_volume"] == 500000
        assert result["trade_count"] == 1

    def test_window_pruning(self):
        """æµ‹è¯•çª—å£æ¸…ç†"""
        # æ¨¡æ‹Ÿ5åˆ†é’Ÿå‰çš„äº¤æ˜“
        old_time = (time.time() - 300) * 1000
        # éªŒè¯æ—§æ•°æ®è¢«æ¸…ç†
```

### 2. é›†æˆæµ‹è¯•ç­–ç•¥

```python
class TestLargeOrderMonitoring:
    """å¤§é¢äº¤æ˜“ç›‘æ§é›†æˆæµ‹è¯•"""

    @pytest.mark.asyncio
    async def test_end_to_end(self):
        """ç«¯åˆ°ç«¯æµ‹è¯•"""
        # 1. å¯åŠ¨ç›‘æ§
        monitor = LargeOrderMonitorProcess()
        await monitor.initialize()

        # 2. æ¨¡æ‹Ÿäº¤æ˜“æ•°æ®
        await self._simulate_trades(monitor.binance_client, 10)

        # 3. ç­‰å¾…å¤„ç†
        await asyncio.sleep(2)

        # 4. éªŒè¯å‘Šè­¦
        assert monitor.stats["alerts_sent"] > 0
```

### 3. æ€§èƒ½æµ‹è¯•ç­–ç•¥

```python
class TestPerformance:
    """æ€§èƒ½æµ‹è¯•"""

    def test_high_throughput(self):
        """é«˜ååé‡æµ‹è¯•"""
        # æ¨¡æ‹Ÿæ¯ç§’1000ç¬”äº¤æ˜“
        start_time = time.time()
        for _ in range(1000):
            trade = create_test_trade()
            aggregator.add_trade(trade, 100000)

        elapsed = time.time() - start_time
        assert elapsed < 1.0  # åº”è¯¥åœ¨1ç§’å†…å¤„ç†1000ç¬”äº¤æ˜“

    def test_memory_usage(self):
        """å†…å­˜ä½¿ç”¨æµ‹è¯•"""
        import psutil
        process = psutil.Process()
        initial_memory = process.memory_info().rss

        # è¿è¡Œ24å°æ—¶
        for _ in range(24 * 60 * 60):
            trade = create_random_trade()
            aggregator.add_trade(trade, random.uniform(1000, 100000))
            time.sleep(1)

        final_memory = process.memory_info().rss
        memory_increase = (final_memory - initial_memory) / 1024 / 1024
        assert memory_increase < 100  # å†…å­˜å¢é•¿å°äº100MB
```

---

## ğŸ“¦ éƒ¨ç½²æ¶æ„

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY requirements.txt .
RUN pip install -r requirements.txt

# å¤åˆ¶åº”ç”¨
COPY src/ ./src/
COPY config/ ./config/

# ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# å¯åŠ¨å‘½ä»¤
CMD ["python", "-m", "src"]
```

### 2. é…ç½®ç®¡ç†

```python
@dataclass
class LargeOrderConfig:
    """å¤§é¢äº¤æ˜“ç›‘æ§é…ç½®"""
    # WebSocketé…ç½®
    binance_ws_url: str = "wss://stream.binance.com:9443/ws"
    max_reconnect_attempts: int = 10
    ping_interval: int = 30

    # èšåˆé…ç½®
    window_minutes: int = 5
    threshold_usd: float = 2_000_000
    cooldown_minutes: int = 5

    # å‘Šè­¦é…ç½®
    rate_limit_per_minute: int = 12
    alert_queue_size: int = 1000

    # USDè½¬æ¢é…ç½®
    cache_ttl_seconds: int = 60
    max_cache_size: int = 1000

    @classmethod
    def from_env(cls) -> "LargeOrderConfig":
        """ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®"""
        return cls(
            threshold_usd=float(os.getenv("LARGE_ORDER_THRESHOLD", "2000000")),
            cooldown_minutes=int(os.getenv("LARGE_ORDER_COOLDOWN", "5")),
            rate_limit_per_minute=int(os.getenv("RATE_LIMIT_PER_MINUTE", "12")),
        )
```

### 3. ç›‘æ§ä¸å‘Šè­¦

```python
# PrometheusæŒ‡æ ‡
from prometheus_client import Counter, Histogram, Gauge

# å®šä¹‰æŒ‡æ ‡
ws_connections = Counter('ws_connections_total', 'WebSocketè¿æ¥æ€»æ•°', ['status'])
trades_processed = Counter('trades_processed_total', 'å¤„ç†äº¤æ˜“æ€»æ•°')
alerts_sent = Counter('alerts_sent_total', 'å‘é€å‘Šè­¦æ€»æ•°')
ws_uptime = Gauge('ws_uptime_seconds', 'WebSocketè¿è¡Œæ—¶é—´')

# æŒ‡æ ‡æ›´æ–°
def on_trade_received(trade):
    trades_processed.inc()
    # å…¶ä»–æŒ‡æ ‡æ›´æ–°...
```

---

## ğŸ”„ æ‰©å±•æ€§è®¾è®¡

### 1. å¤šäº¤æ˜“æ‰€æ”¯æŒ

```python
class ExchangeCollectorFactory:
    """äº¤æ˜“æ‰€æ”¶é›†å™¨å·¥å‚"""

    @staticmethod
    def create_collector(exchange: str, symbols: List[str]) -> BaseExchangeCollector:
        if exchange.lower() == "binance":
            return BinanceWebSocketClient(symbols)
        elif exchange.lower() == "okx":
            return OKXWebSocketClient(symbols)
        elif exchange.lower() == "coinbase":
            return CoinbaseWebSocketClient(symbols)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„äº¤æ˜“æ‰€: {exchange}")
```

### 2. æ’ä»¶ç³»ç»Ÿ

```python
class AlertPlugin(ABC):
    """å‘Šè­¦æ’ä»¶åŸºç±»"""

    @abstractmethod
    async def send_alert(self, alert: ThresholdEvent) -> bool:
        """å‘é€å‘Šè­¦"""
        pass

class SlackAlertPlugin(AlertPlugin):
    """Slackå‘Šè­¦æ’ä»¶"""

    async def send_alert(self, alert: ThresholdEvent) -> bool:
        # å®ç°Slackå‘Šè­¦
        pass

class EmailAlertPlugin(AlertPlugin):
    """é‚®ä»¶å‘Šè­¦æ’ä»¶"""

    async def send_alert(self, alert: ThresholdEvent) -> bool:
        # å®ç°é‚®ä»¶å‘Šè­¦
        pass
```

### 3. é…ç½®çƒ­æ›´æ–°

```python
class ConfigManager:
    """é…ç½®ç®¡ç†å™¨"""

    def __init__(self):
        self.config = LargeOrderConfig()
        self.subscribers = []

    def update_config(self, new_config: LargeOrderConfig):
        """æ›´æ–°é…ç½®"""
        old_config = self.config
        self.config = new_config

        # é€šçŸ¥è®¢é˜…è€…
        for callback in self.subscribers:
            callback(old_config, new_config)

    def subscribe(self, callback: Callable):
        """è®¢é˜…é…ç½®å˜æ›´"""
        self.subscribers.append(callback)
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [å¸å®‰WebSocket APIæ–‡æ¡£](https://binance-docs.github.io/apidocs/spot/en/#trade-streams)
- [WebSocketsåº“æ–‡æ¡£](https://websockets.readthedocs.io/)
- [asyncioå¼‚æ­¥ç¼–ç¨‹æŒ‡å—](https://docs.python.org/3/library/asyncio.html)
- [äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼](https://martinfowler.com/eaaDev/EventSourcing.html)
- [Rate Limiterç®—æ³•](https://en.wikipedia.org/wiki/Token_bucket)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
**æœ€åæ›´æ–°**: 2025-11-10
**ç»´æŠ¤è€…**: OpenSpec AIåŠ©æ‰‹

